""" @package hwm.hardware.devices.drivers.driver
This module defines the base driver classes available to Mercury2. Namely, the HardwareDriver and VirtualDriver classes
which are for are used to represent physical and virtual devices.
"""

# Import required modules
import logging, threading, time

class Driver(object):
  """ Provides the base driver class interface.
  
  This class provides the interface that all Mercury2 device drivers must be derived from. If defines several functions
  common to both virtual and physical devices as well as abstract methods that derived drivers must implement. Note that
  specific driver classes should inherit from either the HardwareDriver or VirtualDriver classes, not this class.
  """
  
  def __init__(self, device_configuration):
    """ Initializes the new device driver.

    @note Derived drivers should always call this method using super() as it sets several required attributes.
    
    @param device_configuration  A dictionary containing the device configuration (from the devices.yml configuration
                                 file).
    """
    
    # Set driver attributes
    self.settings = device_configuration
    self.id = self.settings['id']
    self.allow_concurrent_use = (False if ('allow_concurrent_use' not in self.settings) else 
                                 self.settings['allow_concurrent_use'])
    self.associated_pipelines = {}
    self.command_handler = None
    self.in_use = False

  def write_device_telemetry(self, stream, telemetry_datum, **extra_headers):
    """ Writes device telemetry data back to the device's registered pipelines.
    
    This method writes the specified telemetry datum back to the device's registered pipelines that are currently
    active. The pipelines will pass the telemetry datum along to the sessions currently using them, which will in turn
    pass it to the end user. Device drivers should typically use this method to send extra telemetry to the user.

    @note Device state (generated by the get_state() method) is considered standard telemetry and is automatically 
          collected by the device's pipeline. Device drivers should not report the state returned by get_state() using 
          this method. 

    @param stream           A string identifying which of the device's telemetry streams the datum should be associated 
                            with. The user interface will use this to group telemetry data as it flows in and build an 
                            appropriate display for it.
    @param telemetry_datum  The actual telemetry datum. Can take many forms (e.g. a JSON string or binary webcam image).
    @param **extra_headers  A dictionary containing extra keyword arguments that should be included as additional
                            headers when sending the telemetry datum.
    """

    # Write the telemetry datum to the device's active pipelines
    for temp_pipeline in self.associated_pipelines:
      if self.associated_pipelines[temp_pipeline].is_active:
        self.associated_pipelines[temp_pipeline].write_telemetry_datum(self.id, stream, int(time.time()),
                                                                       telemetry_datum, **extra_headers)

  def write_device_output(self, output_data):
    """ Writes device output to the device's pipelines.
    
    This method writes the specified data chunk to every active pipeline registered to the device that specifies the 
    device as it's output device.

    @note It is important to only write device output to active pipelines that specify the current device as it's output
          source. Otherwise, data may become jumbled and useless. Every device driver should use this method to write 
          their output stream to the pipeline unless it has a specific reason not to (which is rare).
    """

    # Write the data to each active pipeline that specifies this device as its output device
    for temp_pipeline in self.associated_pipelines:
      if self.associated_pipelines[temp_pipeline].is_active:
        if self is self.associated_pipelines[temp_pipeline].output_device:
          self.associated_pipelines[temp_pipeline].write_pipeline_output(output_data)
  
  def write_to_device(self, input_data):
    """ Writes the specified data chunk to the device.

    This method receives device input data from the pipeline. The default implementation of this method simply discards
    the data. Device drivers that can handle an input data stream (such as a radio or TNC) would pass this data to the
    device via its connection to the computer running the hardware manager instance.

    @param input_data  A data chunk of arbitrary size containing data that should be fed to the device.
    """

    pass

  def device_command_handler(self):
    """ Returns the device's command handler.

    This method returns the device's command handler. Individual device drivers are responsible for defining and 
    initializing their command handler, as well as assigning it to their "command_handler" attribute.

    @throw Raises CommandHandlerNotDefined if the device driver does not specify a command handler.
    
    @note Although not required, every device should probably implement a command handler. Even if it doesn't define any
          custom commands, the default command handler abstract class defines some useful common commands such as 
          datastream toggling.
    
    @return Returns the driver's command handler.
    """

    if self.command_handler is None:
      raise CommandHandlerNotDefined("The '"+self.id+"' device does not specify a command handler.")

    return self.command_handler

  def get_state(self):
    """ Returns a dictionary containing the current state of the device.

    This method should return a dictionary containing all available/important state for this device. Any Pipeline using
    the device will use this to assemble a real time stream of the pipeline state.

    @throw Throws StateNotDefined if no state is available for a given device. This can happen if you forget to override
           this method or if the device genuinely doesn't have any state.

    @return Should return a dictionary containing the device's current state. 
    """

    raise StateNotDefined("The '"+self.id+"' device did not specify any device state.")

  def register_pipeline(self, pipeline):
    """ Associates a pipeline with the device.

    This method registers the specified pipeline with the device. This allows the device driver to use the pipeline to 
    pass along device output, register and load services, and write to the pipeline telemetry stream.

    @note This method allows multiple pipelines to be registered with the device. This is because devices can belong to
          several pipelines at a time. In addition, some devices (such as webcams) allow for concurrent use by multiple 
          pipelines.
    @note Device registration occurs automatically during the initial pipeline setup process and only occurs once.
    
    @throws Raises PipelineAlreadyRegistered in the event that the user tries to register the same pipeline twice with
            the device.

    @param pipeline  The Pipeline to register with the device.
    """

    # Make sure the pipeline hasn't been registered yet
    if pipeline.id in self.associated_pipelines:
      raise PipelineAlreadyRegistered("The '"+pipeline.id+"' pipeline has already been registered with the '"+self.id+
                                      "' device.")

    # Register the pipeline
    self.associated_pipelines[pipeline.id] = pipeline

  def reserve_device(self):
    """ Reserves the device for a user reservation.

    This method tries to acquire the device lock and raises an exception if it can't. However, if the device is
    configured for concurrent access it will simply pass (as there is nothing to reserve).
    
    @note Pipelines will typically use this method to lock their constituent hardware devices when a session requests a 
          specific pipeline. This prevents two different sessions from accidentally allowing access to the same device 
          at the same time while still allowing access to the driver for other things (like admin commands which can 
          arrive at any time and are independent of an active session).
    
    @throw Throws DeviceInUse if the device has already been reserved by another pipeline.
    """
    
    # Check if the device allows concurrent use
    if not self.allow_concurrent_use:
      # Check if the device is being used
      if self.in_use:
        raise DeviceInUse("The requested device is currently being used and can't be reserved.")

      self.in_use = True
  
  def free_device(self):
    """ Frees the device lock.
    
    @note The pipeline that is currently using this device should call this during the sesssion cleanup process.
    @note If a device allows concurrent use, this method will have no effect.
    """
    
    # Check if the device allows concurrent use
    if not self.allow_concurrent_use:
      # Free the device
      self.in_use = False

class HardwareDriver(Driver):
  """ The base hardware driver interface.

  This class provides the base driver interface that must be implemented when developing physical hardware device
  drivers for the hardware manager.
  """

  def __init__(self, device_configuration):
    """ Sets up the physical hardware driver.

    @param device_configuration  A dictionary containing the device configuration (from the devices.yml configuration
                                 file).
    """

    # Call the base driver constructor
    super(HardwareDriver,self).__init__(device_configuration)

class VirtualDriver(Driver):
  """ Defines the base driver used for virtual devices.
  """

  def __init__(self, device_configuration):
    """ Sets up the virtual device driver.

    @param device_configuration  A dictionary containing the device configuration (from the devices.yml configuration
                                 file).
    """

    # Call the base driver constructor
    super(VirtualDriver,self).__init__(device_configuration)

# Define custom driver exceptions
class DriverError(Exception):
  pass
class PipelineAlreadyRegistered(DriverError):
  pass
class PipelineNotRegistered(DriverError):
  pass
class StateNotDefined(DriverError):
  pass
class CommandHandlerNotDefined(DriverError):
  pass
class DeviceInUse(DriverError):
  pass
  